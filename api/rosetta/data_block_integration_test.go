// Copyright 2021 Alvalor S.A.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

// +build integration

package rosetta_test

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"strconv"
	"testing"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/onflow/flow-go/model/flow"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/optakt/flow-dps/api/rosetta"
	"github.com/optakt/flow-dps/models/dps"
	"github.com/optakt/flow-dps/rosetta/configuration"
	"github.com/optakt/flow-dps/rosetta/identifier"
	"github.com/optakt/flow-dps/rosetta/meta"
	"github.com/optakt/flow-dps/rosetta/object"
)

type blockIDValidationFn func(identifier.Block)
type transactionValidationFn func(*object.Transaction)

func TestGetBlock(t *testing.T) {

	db := setupDB(t)
	api := setupAPI(t, db)

	// headers of known blocks we want to verify
	var (
		firstHeader = knownHeaders(1)
		midHeader1  = knownHeaders(13)
		midHeader2  = knownHeaders(43)
		midHeader3  = knownHeaders(44)
		lastHeader  = knownHeaders(425) // header of last indexed block
	)

	tests := []struct {
		name string

		request rosetta.BlockRequest

		wantTimestamp        int64
		wantParentHash       string
		validateTransactions transactionValidationFn
		validateBlock        blockIDValidationFn
	}{
		{
			// TODO: check - you can just save the header and use timestamp/parent id hash/blockIDValidatorFromHeader from there
			name:           "child of first block",
			request:        blockRequest(firstHeader),
			wantTimestamp:  rosettaTime(firstHeader.Timestamp),
			wantParentHash: firstHeader.ParentID.String(),
			validateBlock:  validatorFromHeader(t, firstHeader),
		},
		{
			// initial transfer of currency from the root account to the user - 100 tokens
			name:                 "block mid-chain with transactions",
			request:              blockRequest(midHeader1),
			wantTimestamp:        rosettaTime(midHeader1.Timestamp),
			wantParentHash:       midHeader1.ParentID.String(),
			validateBlock:        validatorFromHeader(t, midHeader1),
			validateTransactions: validateSingleTransfer(t, "a9c9ab28ea76b7dbfd1f2666f74348e4188d67cf68248df6634cee3f06adf7b1", "8c5303eaa26202d6", "754aed9de6197641", 100_00000000),
		},
		{
			name:           "block mid-chain without transactions",
			request:        blockRequest(midHeader2),
			wantTimestamp:  rosettaTime(midHeader2.Timestamp),
			validateBlock:  validatorFromHeader(t, midHeader2),
			wantParentHash: midHeader2.ParentID.String(),
		},
		{
			// transaction between two users
			name:                 "second block mid-chain with transactions",
			request:              blockRequest(midHeader3),
			wantTimestamp:        rosettaTime(midHeader3.Timestamp),
			wantParentHash:       midHeader3.ParentID.String(),
			validateBlock:        validatorFromHeader(t, midHeader3),
			validateTransactions: validateSingleTransfer(t, "d5c18baf6c8d11f0693e71dbb951c4856d4f25a456f4d5285a75fd73af39161c", "754aed9de6197641", "631e88ae7f1d7c20", 1),
		},
		{
			name: "lookup of a block mid-chain by index only",
			request: rosetta.BlockRequest{
				NetworkID: defaultNetworkID(),
				BlockID:   identifier.Block{Index: midHeader3.Height},
			},
			wantTimestamp:        rosettaTime(midHeader3.Timestamp),
			wantParentHash:       midHeader3.ParentID.String(),
			validateTransactions: validateSingleTransfer(t, "d5c18baf6c8d11f0693e71dbb951c4856d4f25a456f4d5285a75fd73af39161c", "754aed9de6197641", "631e88ae7f1d7c20", 1),
			validateBlock:        validateBlockID(t, midHeader3.Height, midHeader3.ID().String()), // verify that the returned block ID has both height and hash
		},
		{
			name:           "last indexed block",
			request:        blockRequest(lastHeader),
			wantTimestamp:  rosettaTime(lastHeader.Timestamp),
			validateBlock:  validatorFromHeader(t, lastHeader),
			wantParentHash: lastHeader.ParentID.String(),
		},
	}

	for _, test := range tests {

		test := test
		t.Run(test.name, func(t *testing.T) {

			t.Parallel()

			enc, err := json.Marshal(test.request)
			require.NoError(t, err)

			req := httptest.NewRequest(http.MethodPost, "/block", bytes.NewReader(enc))
			req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)

			rec := httptest.NewRecorder()

			ctx := echo.New().NewContext(req, rec)

			err = api.Block(ctx)
			assert.NoError(t, err)

			// unpack response
			var blockResponse rosetta.BlockResponse
			require.NoError(t, json.Unmarshal(rec.Body.Bytes(), &blockResponse))

			if assert.NotNil(t, blockResponse.Block) {

				test.validateBlock(blockResponse.Block.ID)

				// verify the parent block index is correct
				assert.Equal(t, test.request.BlockID.Index-1, blockResponse.Block.ParentID.Index)
				assert.Equal(t, test.wantParentHash, blockResponse.Block.ParentID.Hash)

				assert.Equal(t, test.wantTimestamp, blockResponse.Block.Timestamp)

				if test.validateTransactions != nil {

					if assert.GreaterOrEqual(t, len(blockResponse.Block.Transactions), 1) {
						test.validateTransactions(blockResponse.Block.Transactions[0])
					}
				}
			}
		})
	}
}

func TestBlockErrors(t *testing.T) {

	db := setupDB(t)
	api := setupAPI(t, db)

	const (
		invalidBlockchain = "invalid-blockchain"
		invalidNetwork    = "invalid-network"

		validBlockID     = "810c9d25535107ba8729b1f26af2552e63d7b38b1e4cb8c848498faea1354cbd"
		validBlockHeight = 44

		trimmedBlockID = "dab186b45199c0c26060ea09288b2f16032da40fc54c81bb2a8267a5c13906e"  // blockID a character short
		invalidBlockID = "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz" // invalid hex value
		validLength    = 64
		lastHeight     = 425
	)

	tests := []struct {
		name string

		request rosetta.BlockRequest

		// HTTP/handler errors
		wantStatusCode int

		// rosetta errors - validated separately since it makes reporting mismatches more manageable
		wantRosettaError            meta.ErrorDefinition
		wantRosettaErrorDescription string
		wantRosettaErrorDetails     map[string]interface{}
	}{
		{
			name: "missing network blockchain name",
			request: rosetta.BlockRequest{
				NetworkID: identifier.Network{
					Blockchain: "",
					Network:    dps.FlowTestnet.String(),
				},
				BlockID: identifier.Block{
					Index: validBlockHeight,
					Hash:  validBlockID,
				},
			},

			wantStatusCode:              http.StatusBadRequest,
			wantRosettaError:            configuration.ErrorInvalidFormat,
			wantRosettaErrorDescription: "blockchain identifier: blockchain field is empty",
			wantRosettaErrorDetails:     nil,
		},
		{
			name: "wrong network blockchain name",
			request: rosetta.BlockRequest{
				NetworkID: identifier.Network{
					Blockchain: invalidBlockchain,
					Network:    dps.FlowTestnet.String(),
				},
				BlockID: identifier.Block{
					Index: validBlockHeight,
					Hash:  validBlockID,
				},
			},

			wantStatusCode:              http.StatusUnprocessableEntity,
			wantRosettaError:            configuration.ErrorInvalidNetwork,
			wantRosettaErrorDescription: fmt.Sprintf("invalid network identifier blockchain (have: %s, want: %s)", invalidBlockchain, dps.FlowBlockchain),
			wantRosettaErrorDetails:     map[string]interface{}{"blockchain": invalidBlockchain, "network": dps.FlowTestnet.String()},
		},
		{
			name: "missing network name",
			request: rosetta.BlockRequest{
				NetworkID: identifier.Network{
					Blockchain: dps.FlowBlockchain,
					Network:    "",
				},
				BlockID: identifier.Block{
					Index: validBlockHeight,
					Hash:  validBlockID,
				},
			},

			wantStatusCode:              http.StatusBadRequest,
			wantRosettaError:            configuration.ErrorInvalidFormat,
			wantRosettaErrorDescription: "blockchain identifier: network field is empty",
			wantRosettaErrorDetails:     nil,
		},
		{
			name: "wrong network name",
			request: rosetta.BlockRequest{
				NetworkID: identifier.Network{
					Blockchain: dps.FlowBlockchain,
					Network:    invalidNetwork,
				},
				BlockID: identifier.Block{
					Index: validBlockHeight,
					Hash:  validBlockID,
				},
			},

			wantStatusCode:              http.StatusUnprocessableEntity,
			wantRosettaError:            configuration.ErrorInvalidNetwork,
			wantRosettaErrorDescription: fmt.Sprintf("invalid network identifier network (have: %s, want: %s)", invalidNetwork, dps.FlowTestnet.String()),
			wantRosettaErrorDetails:     map[string]interface{}{"blockchain": dps.FlowBlockchain, "network": invalidNetwork},
		},
		{
			name: "missing block height and hash",
			request: rosetta.BlockRequest{
				NetworkID: defaultNetworkID(),
				BlockID: identifier.Block{
					Index: 0,
					Hash:  "",
				},
			},

			wantStatusCode:              http.StatusBadRequest,
			wantRosettaError:            configuration.ErrorInvalidFormat,
			wantRosettaErrorDescription: "block identifier: at least one of hash or index is required",
			wantRosettaErrorDetails:     nil,
		},
		{
			name: "wrong length of block id",
			request: rosetta.BlockRequest{
				NetworkID: defaultNetworkID(),
				BlockID: identifier.Block{
					Index: 43,
					Hash:  trimmedBlockID,
				},
			},

			wantStatusCode:              http.StatusBadRequest,
			wantRosettaError:            configuration.ErrorInvalidFormat,
			wantRosettaErrorDescription: fmt.Sprintf("block identifier: hash field has wrong length (have: %d, want: %d)", len(trimmedBlockID), validLength),
			wantRosettaErrorDetails:     nil,
		},
		{
			name: "missing block height",
			request: rosetta.BlockRequest{
				NetworkID: defaultNetworkID(),
				BlockID: identifier.Block{
					Hash: validBlockID,
				},
			},

			wantStatusCode:              http.StatusInternalServerError,
			wantRosettaError:            configuration.ErrorInternal,
			wantRosettaErrorDescription: "could not validate block: block access with hash currently not supported",
			wantRosettaErrorDetails:     nil,
		},
		{
			name: "invalid block hash",
			request: rosetta.BlockRequest{
				NetworkID: defaultNetworkID(),
				BlockID: identifier.Block{
					Index: 13,
					Hash:  invalidBlockID,
				},
			},

			wantStatusCode:              http.StatusUnprocessableEntity,
			wantRosettaError:            configuration.ErrorInvalidBlock,
			wantRosettaErrorDescription: "block hash is not a valid hex-encoded string",
			wantRosettaErrorDetails:     map[string]interface{}{"index": uint64(13), "hash": invalidBlockID},
		},
		{
			name: "unknown block",
			request: rosetta.BlockRequest{
				NetworkID: defaultNetworkID(),
				BlockID: identifier.Block{
					Index: lastHeight + 1,
				},
			},

			wantStatusCode:              http.StatusUnprocessableEntity,
			wantRosettaError:            configuration.ErrorUnknownBlock,
			wantRosettaErrorDescription: fmt.Sprintf("block index is above last indexed block (last: %d)", lastHeight),
			wantRosettaErrorDetails:     map[string]interface{}{"index": uint64(426), "hash": ""},
		},
		{
			name: "mismatched block height and hash",
			request: rosetta.BlockRequest{
				NetworkID: defaultNetworkID(),
				BlockID: identifier.Block{
					Index: validBlockHeight - 1,
					Hash:  validBlockID,
				},
			},

			wantStatusCode:              http.StatusUnprocessableEntity,
			wantRosettaError:            configuration.ErrorInvalidBlock,
			wantRosettaErrorDescription: fmt.Sprintf("block hash does not match known hash for height (known: %s)", knownHeaders(validBlockHeight-1).ID().String()),
			wantRosettaErrorDetails:     map[string]interface{}{"index": uint64(validBlockHeight - 1), "hash": validBlockID},
		},
		{
			// effectively the same as the 'missing blockchain name' test case, since it's the first check we'll do
			name:    "empty block request",
			request: rosetta.BlockRequest{},

			wantStatusCode:              http.StatusBadRequest,
			wantRosettaError:            configuration.ErrorInvalidFormat,
			wantRosettaErrorDescription: "blockchain identifier: blockchain field is empty",
			wantRosettaErrorDetails:     nil,
		},
	}

	for _, test := range tests {
		test := test

		t.Run(test.name, func(t *testing.T) {

			t.Parallel()

			enc, err := json.Marshal(test.request)
			require.NoError(t, err)

			req := httptest.NewRequest(http.MethodPost, "/block", bytes.NewReader(enc))
			req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)

			rec := httptest.NewRecorder()
			ctx := echo.New().NewContext(req, rec)

			// execute the request
			err = api.Block(ctx)
			assert.Error(t, err)

			echoErr, ok := err.(*echo.HTTPError)
			require.True(t, ok)

			// verify HTTP status code
			assert.Equal(t, test.wantStatusCode, echoErr.Code)

			gotErr, ok := echoErr.Message.(rosetta.Error)
			require.True(t, ok)

			assert.Equal(t, test.wantRosettaError, gotErr.ErrorDefinition)
			assert.Equal(t, test.wantRosettaErrorDescription, gotErr.Description)
			assert.Equal(t, test.wantRosettaErrorDetails, gotErr.Details)
		})
	}
}

func TestMalformedBlockRequest(t *testing.T) {

	db := setupDB(t)
	api := setupAPI(t, db)

	tests := []struct {
		name     string
		payload  []byte
		mimeType string
	}{
		{
			name:     "empty request",
			payload:  []byte(``),
			mimeType: echo.MIMEApplicationJSON,
		},
		{
			name:     "wrong field type",
			payload:  []byte(`{ "network_identifier": { "blockchain": "flow", "network": 99} }`),
			mimeType: echo.MIMEApplicationJSON,
		},
		{
			name: "unclosed bracket",
			payload: []byte(`{ "network_identifier": { "blockchain": "flow", "network": "flow-testnet" },
							   "block_identifier": { "index": 13, "hash": "af528bb047d6cd1400a326bb127d689607a096f5ccd81d8903dfebbac26afb23" }`),
			mimeType: echo.MIMEApplicationJSON,
		},
		{
			// TODO: check if this should be treated as an error - echo will
			name: "valid payload with no mime type set",
			payload: []byte(`{ "network_identifier": { "blockchain": "flow", "network": "flow-testnet" },
							   "block_identifier": { "index": 13, "hash": "af528bb047d6cd1400a326bb127d689607a096f5ccd81d8903dfebbac26afb23" } }`),
			mimeType: "",
		},
	}

	for _, test := range tests {
		test := test

		t.Run(test.name, func(t *testing.T) {

			t.Parallel()

			req := httptest.NewRequest(http.MethodPost, "/block", bytes.NewReader(test.payload))
			req.Header.Set(echo.HeaderContentType, test.mimeType)

			rec := httptest.NewRecorder()
			ctx := echo.New().NewContext(req, rec)

			err := api.Block(ctx)
			assert.Error(t, err)

			echoErr, ok := err.(*echo.HTTPError)
			require.True(t, ok)

			assert.Equal(t, http.StatusBadRequest, echoErr.Code)

			gotErr, ok := echoErr.Message.(rosetta.Error)
			require.True(t, ok)

			assert.Equal(t, configuration.ErrorInvalidFormat, gotErr.ErrorDefinition)
			assert.NotEmpty(t, gotErr.Description)
		})
	}

}

// blockRequest generates a BlockRequest with the specified parameters.
func blockRequest(header flow.Header) rosetta.BlockRequest {

	return rosetta.BlockRequest{
		NetworkID: defaultNetworkID(),
		BlockID: identifier.Block{
			Index: header.Height,
			Hash:  header.ID().String(),
		},
	}
}

func validateSingleTransfer(t *testing.T, hash string, from string, to string, amount int64) transactionValidationFn {

	t.Helper()

	return func(tx *object.Transaction) {

		assert.Equal(t, tx.ID.Hash, hash)
		assert.Equal(t, len(tx.Operations), 2)

		relatedOperations := make(map[uint]uint)

		for _, op := range tx.Operations {

			// save related operation IDs in a map so we can cross reference them
			// TODO: check - is this special-casing the test too much perhaps?
			// operation can have multiple related operations,
			// but also this function does state that it's verifying a single transfer

			if assert.Len(t, op.RelatedIDs, 1) {
				relatedOperations[op.ID.Index] = op.RelatedIDs[0].Index
			}

			// validate operation and status
			assert.Equal(t, op.Type, dps.OperationTransfer)
			assert.Equal(t, op.Status, dps.StatusCompleted)

			// validate currency
			assert.Equal(t, op.Amount.Currency.Symbol, dps.FlowSymbol)
			assert.Equal(t, op.Amount.Currency.Decimals, uint(dps.FlowDecimals))

			// validate address
			address := op.AccountID.Address
			if address != from && address != to {
				t.Errorf("unexpected account address (%v)", address)
			}

			// validate transfered amount
			wantValue := strconv.FormatInt(amount, 10)
			if address == from {
				wantValue = "-" + wantValue
			}

			assert.Equal(t, op.Amount.Value, wantValue)
		}

		// cross-reference related operations - verify that the related operation backlinks to the original one
		for id, relatedID := range relatedOperations {
			assert.Contains(t, relatedOperations, relatedID)
			assert.Equal(t, id, relatedOperations[relatedID])
		}
	}
}

func validateBlockID(t *testing.T, height uint64, hash string) blockIDValidationFn {

	t.Helper()

	return func(blockID identifier.Block) {
		assert.Equal(t, height, blockID.Index)
		assert.Equal(t, hash, blockID.Hash)
	}
}

func validatorFromHeader(t *testing.T, header flow.Header) blockIDValidationFn {
	return validateBlockID(t, header.Height, header.ID().String())
}

func rosettaTime(t time.Time) int64 {
	return t.UnixNano() / 1_000_000
}

func knownHeaders(height uint64) flow.Header {

	switch height {

	case 1:
		return flow.Header{
			ChainID:     dps.FlowTestnet,
			ParentID:    flow.HashToID([]byte{0xd4, 0x7b, 0x1b, 0xf7, 0xf3, 0x7e, 0x19, 0x2c, 0xf8, 0x3d, 0x2b, 0xee, 0x3f, 0x63, 0x32, 0xb0, 0xd9, 0xb1, 0x5c, 0xa, 0xa7, 0x66, 0xd, 0x1e, 0x53, 0x22, 0xea, 0x96, 0x46, 0x67, 0xb3, 0x33}),
			Height:      1,
			PayloadHash: flow.HashToID([]byte{0x7b, 0x3b, 0x31, 0x3b, 0xd8, 0x3e, 0x1, 0xd1, 0x3c, 0x44, 0x9d, 0x4d, 0xd4, 0xba, 0xc0, 0x41, 0x37, 0xf5, 0x9, 0xb, 0xcb, 0x30, 0x5d, 0xdd, 0x75, 0x2, 0x98, 0xbd, 0x16, 0xe5, 0x33, 0x9b}),
			Timestamp:   time.Unix(0, 1621337323243086400).UTC(),
			View:        2,
			ParentVoterIDs: []flow.Identifier{
				flow.HashToID([]byte{0x5, 0x55, 0x33, 0x7e, 0xf, 0x66, 0x1e, 0xc9, 0xb0, 0x7e, 0xbb, 0x69, 0x46, 0x8, 0x13, 0x16, 0xfa, 0x65, 0xc0, 0xba, 0xca, 0x6b, 0xd4, 0x70, 0x5b, 0xf6, 0x9d, 0x56, 0xa9, 0xf5, 0xb8, 0xa3}),
				flow.HashToID([]byte{0x45, 0x51, 0xbe, 0x34, 0xd9, 0xf7, 0xa9, 0x3b, 0x0, 0xd2, 0x87, 0xbd, 0x68, 0x3f, 0x7d, 0xd6, 0x34, 0x5e, 0x65, 0x90, 0x72, 0x40, 0x40, 0x5, 0x54, 0xfb, 0xdf, 0xa1, 0x69, 0x7d, 0x3b, 0xfa}),
				flow.HashToID([]byte{0xd3, 0x5f, 0xac, 0xa6, 0x7a, 0xbc, 0x6, 0xc3, 0x34, 0xb1, 0xe5, 0xa7, 0x88, 0x23, 0x98, 0xda, 0xe9, 0xc1, 0xda, 0xd9, 0x13, 0xe5, 0x60, 0x9e, 0xe1, 0xd4, 0x63, 0xd5, 0x5a, 0x22, 0x44, 0xf7}),
			},
			ParentVoterSig: []byte{0xa0, 0x2a, 0xed, 0xa7, 0xc4, 0xe1, 0x40, 0x8e, 0x70, 0xe7, 0xa6, 0x7d, 0x81, 0x99, 0x24, 0xf4, 0x7c, 0x30, 0x42, 0x2, 0xe5, 0xaa, 0xfa, 0x89, 0x89, 0xda, 0x9d, 0x22, 0xb5, 0x45, 0xb0, 0xc2, 0xa4, 0x4c, 0x4b, 0xf3, 0xe1, 0xdf, 0x31, 0x73, 0xa2, 0x3e, 0x48, 0x5, 0xb4, 0xec, 0x5d, 0xcf, 0x8a, 0x6f, 0x42, 0xe7, 0xdd, 0xad, 0x7d, 0x4b, 0x7e, 0xc, 0xcb, 0xc, 0x6, 0x64, 0x10, 0x86, 0x4d, 0xd6, 0x89, 0x3a, 0x6f, 0x1e, 0xc4, 0xef, 0x6c, 0x18, 0xbf, 0xd5, 0x3a, 0x36, 0x25, 0xf0, 0xf9, 0xb0, 0x1f, 0x27, 0x4e, 0x4d, 0x72, 0x34, 0xf4, 0x51, 0xcc, 0x7d, 0x81, 0x86, 0xed, 0xb2},
			ProposerID:     flow.HashToID([]byte{0x5, 0x55, 0x33, 0x7e, 0xf, 0x66, 0x1e, 0xc9, 0xb0, 0x7e, 0xbb, 0x69, 0x46, 0x8, 0x13, 0x16, 0xfa, 0x65, 0xc0, 0xba, 0xca, 0x6b, 0xd4, 0x70, 0x5b, 0xf6, 0x9d, 0x56, 0xa9, 0xf5, 0xb8, 0xa3}),
			ProposerSig:    []byte{0x8f, 0x7a, 0x5c, 0xbb, 0x4d, 0xfa, 0x46, 0x6, 0xe9, 0x9a, 0xd6, 0xea, 0xa1, 0xa3, 0x1a, 0x3b, 0xb4, 0xa4, 0xc0, 0xa4, 0x4a, 0xa6, 0xe7, 0xe6, 0x8b, 0x5e, 0x5e, 0x8b, 0x3f, 0xf, 0xa3, 0x32, 0x68, 0xee, 0x59, 0x20, 0x97, 0xa2, 0x38, 0xd5, 0x25, 0x64, 0xc3, 0x54, 0x1f, 0x1f, 0x9c, 0x5a, 0xaa, 0xc5, 0x1, 0xf3, 0xff, 0x3f, 0x83, 0x4, 0x9f, 0xed, 0xc3, 0x84, 0xf8, 0x5, 0xe6, 0x15, 0xf, 0x21, 0x50, 0x27, 0x3a, 0x72, 0xe3, 0xa0, 0x35, 0xec, 0x43, 0x48, 0x40, 0x9b, 0xef, 0xfa, 0x1b, 0x20, 0xb6, 0x7, 0x53, 0xcf, 0x38, 0x9f, 0x87, 0xf0, 0x52, 0x47, 0xfc, 0xc4, 0x70, 0x47},
		}

	case 13:
		return flow.Header{
			ChainID:     dps.FlowTestnet,
			ParentID:    flow.HashToID([]byte{0x90, 0x35, 0xc5, 0x58, 0x37, 0x9b, 0x20, 0x8e, 0xba, 0x11, 0x13, 0xc, 0x92, 0x85, 0x37, 0xfe, 0x50, 0xad, 0x93, 0xcd, 0xee, 0x31, 0x49, 0x80, 0xfc, 0xcb, 0x69, 0x5a, 0xa3, 0x1d, 0xf7, 0xfc}),
			Height:      13,
			PayloadHash: flow.HashToID([]byte{0xd0, 0x43, 0x96, 0xd9, 0x5, 0x79, 0xea, 0xe8, 0xfc, 0xf5, 0x90, 0x6f, 0xce, 0xde, 0x4d, 0x26, 0xbe, 0x66, 0x7d, 0x5d, 0x6e, 0x36, 0x8c, 0xd1, 0x99, 0xed, 0x8a, 0x66, 0x17, 0x84, 0x67, 0xf2}),
			Timestamp:   time.Unix(0, 1621338403243086400).UTC(),
			View:        14,
			ParentVoterIDs: []flow.Identifier{
				flow.HashToID([]byte{0x5, 0x55, 0x33, 0x7e, 0xf, 0x66, 0x1e, 0xc9, 0xb0, 0x7e, 0xbb, 0x69, 0x46, 0x8, 0x13, 0x16, 0xfa, 0x65, 0xc0, 0xba, 0xca, 0x6b, 0xd4, 0x70, 0x5b, 0xf6, 0x9d, 0x56, 0xa9, 0xf5, 0xb8, 0xa3}),
				flow.HashToID([]byte{0x45, 0x51, 0xbe, 0x34, 0xd9, 0xf7, 0xa9, 0x3b, 0x0, 0xd2, 0x87, 0xbd, 0x68, 0x3f, 0x7d, 0xd6, 0x34, 0x5e, 0x65, 0x90, 0x72, 0x40, 0x40, 0x5, 0x54, 0xfb, 0xdf, 0xa1, 0x69, 0x7d, 0x3b, 0xfa}),
				flow.HashToID([]byte{0xd3, 0x5f, 0xac, 0xa6, 0x7a, 0xbc, 0x6, 0xc3, 0x34, 0xb1, 0xe5, 0xa7, 0x88, 0x23, 0x98, 0xda, 0xe9, 0xc1, 0xda, 0xd9, 0x13, 0xe5, 0x60, 0x9e, 0xe1, 0xd4, 0x63, 0xd5, 0x5a, 0x22, 0x44, 0xf7}),
			},
			ParentVoterSig: []byte{0x92, 0xf6, 0x89, 0x55, 0x76, 0xb, 0x5, 0xe5, 0x89, 0xae, 0x3e, 0x21, 0xa6, 0x4a, 0x4f, 0xb6, 0xd4, 0x40, 0xcc, 0x94, 0x90, 0x8f, 0x40, 0xeb, 0xcd, 0xfd, 0x30, 0x45, 0xd7, 0x94, 0xc8, 0x95, 0xfe, 0xf1, 0x7e, 0xd8, 0x71, 0xce, 0x6c, 0x3, 0xb8, 0x4f, 0x5f, 0x8, 0x30, 0x2, 0x8a, 0x85, 0x90, 0x2a, 0xc5, 0xd, 0x81, 0x49, 0x11, 0xd9, 0x37, 0x35, 0x6f, 0xf9, 0x3f, 0x7b, 0x52, 0x4, 0xdb, 0x5a, 0x36, 0x81, 0xda, 0xa6, 0x47, 0xb5, 0xd9, 0xa7, 0xec, 0x6, 0xda, 0x34, 0x70, 0xdf, 0x8, 0x4a, 0xd5, 0xd0, 0x14, 0xf7, 0x2d, 0xd7, 0x5b, 0x66, 0x39, 0x64, 0x3c, 0xf1, 0xbb, 0xe4},
			ProposerID:     flow.HashToID([]byte{0x5, 0x55, 0x33, 0x7e, 0xf, 0x66, 0x1e, 0xc9, 0xb0, 0x7e, 0xbb, 0x69, 0x46, 0x8, 0x13, 0x16, 0xfa, 0x65, 0xc0, 0xba, 0xca, 0x6b, 0xd4, 0x70, 0x5b, 0xf6, 0x9d, 0x56, 0xa9, 0xf5, 0xb8, 0xa3}),
			ProposerSig:    []byte{0x98, 0xe2, 0xf9, 0x46, 0xc4, 0xd7, 0x71, 0xc6, 0xf6, 0x56, 0x21, 0xe, 0xe7, 0xa4, 0x9c, 0xaa, 0xc, 0x3f, 0x7a, 0x75, 0xb9, 0x53, 0x95, 0x37, 0xdd, 0xb7, 0x4b, 0x7f, 0xfc, 0x1e, 0x1a, 0xe9, 0xfe, 0xbb, 0x56, 0x2e, 0xb8, 0x6e, 0xf6, 0xd8, 0x25, 0x4d, 0x5f, 0xee, 0x46, 0x1d, 0xd, 0xd4, 0x82, 0xeb, 0x7, 0xde, 0xa2, 0x8, 0x58, 0x13, 0xba, 0xfb, 0xeb, 0x2e, 0xcd, 0x88, 0x2e, 0x7c, 0x1b, 0xe8, 0xc5, 0x1d, 0x84, 0xe, 0xa2, 0x10, 0xbe, 0xe3, 0xb6, 0x26, 0x87, 0x4b, 0x6c, 0xbf, 0xc2, 0xe0, 0x85, 0xf4, 0x7e, 0xf5, 0xf3, 0x55, 0x5d, 0xd3, 0x49, 0xff, 0xc8, 0xe3, 0xb5, 0x53},
		}

	case 43:

		return flow.Header{
			ChainID:     dps.FlowTestnet,
			ParentID:    flow.HashToID([]byte{0x91, 0xc0, 0xb, 0x22, 0xdc, 0x9b, 0x84, 0x28, 0x1d, 0x29, 0x3f, 0x6e, 0x1f, 0xf6, 0x80, 0x13, 0x32, 0x39, 0xad, 0xdd, 0x8b, 0x2, 0x20, 0xa2, 0x44, 0x55, 0x4e, 0x1d, 0x96, 0xae, 0xd8, 0xe0}),
			Height:      43,
			PayloadHash: flow.HashToID([]byte{0x5, 0xae, 0xad, 0x1e, 0xaa, 0x5f, 0x40, 0x85, 0xf0, 0xb4, 0xa2, 0x67, 0x67, 0x3d, 0x13, 0xc4, 0x6, 0x26, 0xbf, 0xe9, 0x3d, 0xf9, 0x90, 0x38, 0x5c, 0xf3, 0xbc, 0x7a, 0xfd, 0x77, 0x15, 0x21}),
			Timestamp:   time.Unix(0, 1621341103243086400).UTC(),
			View:        44,
			ParentVoterIDs: []flow.Identifier{
				flow.HashToID([]byte{0x5, 0x55, 0x33, 0x7e, 0xf, 0x66, 0x1e, 0xc9, 0xb0, 0x7e, 0xbb, 0x69, 0x46, 0x8, 0x13, 0x16, 0xfa, 0x65, 0xc0, 0xba, 0xca, 0x6b, 0xd4, 0x70, 0x5b, 0xf6, 0x9d, 0x56, 0xa9, 0xf5, 0xb8, 0xa3}),
				flow.HashToID([]byte{0x45, 0x51, 0xbe, 0x34, 0xd9, 0xf7, 0xa9, 0x3b, 0x0, 0xd2, 0x87, 0xbd, 0x68, 0x3f, 0x7d, 0xd6, 0x34, 0x5e, 0x65, 0x90, 0x72, 0x40, 0x40, 0x5, 0x54, 0xfb, 0xdf, 0xa1, 0x69, 0x7d, 0x3b, 0xfa}),
				flow.HashToID([]byte{0xd3, 0x5f, 0xac, 0xa6, 0x7a, 0xbc, 0x6, 0xc3, 0x34, 0xb1, 0xe5, 0xa7, 0x88, 0x23, 0x98, 0xda, 0xe9, 0xc1, 0xda, 0xd9, 0x13, 0xe5, 0x60, 0x9e, 0xe1, 0xd4, 0x63, 0xd5, 0x5a, 0x22, 0x44, 0xf7}),
			},
			ParentVoterSig: []byte{0x95, 0x8e, 0x2b, 0x47, 0x8, 0xfa, 0x12, 0xa5, 0x3, 0x99, 0xbc, 0xce, 0xb5, 0x82, 0xac, 0x71, 0x7a, 0x9, 0x87, 0x60, 0x17, 0x70, 0x1c, 0x51, 0xa, 0xef, 0x45, 0x9e, 0x7, 0xc1, 0x4, 0x92, 0xa, 0x7b, 0xd6, 0x13, 0xb0, 0x6c, 0x45, 0x4c, 0x2c, 0xba, 0xc4, 0xa3, 0xb0, 0xf6, 0x87, 0x64, 0x93, 0x83, 0xca, 0x2b, 0x48, 0x41, 0x7f, 0x84, 0x2b, 0xf1, 0x84, 0xda, 0x2e, 0xec, 0xd7, 0xc, 0xb6, 0x54, 0x19, 0x8e, 0x20, 0x1e, 0xa8, 0x8c, 0xb0, 0x38, 0xab, 0xc4, 0x40, 0x13, 0x0, 0xfc, 0x55, 0x26, 0xb8, 0xc5, 0x5a, 0xa9, 0xd4, 0xe4, 0x9f, 0xf7, 0x3c, 0x68, 0x68, 0xdf, 0x38, 0x54},
			ProposerID:     flow.HashToID([]byte{0x5, 0x55, 0x33, 0x7e, 0xf, 0x66, 0x1e, 0xc9, 0xb0, 0x7e, 0xbb, 0x69, 0x46, 0x8, 0x13, 0x16, 0xfa, 0x65, 0xc0, 0xba, 0xca, 0x6b, 0xd4, 0x70, 0x5b, 0xf6, 0x9d, 0x56, 0xa9, 0xf5, 0xb8, 0xa3}),
			ProposerSig:    []byte{0xb0, 0x2, 0x4f, 0xfc, 0x71, 0xba, 0x38, 0xc1, 0x24, 0x79, 0xa0, 0xd2, 0x66, 0xe3, 0xfb, 0x20, 0xe2, 0x2e, 0x27, 0xe4, 0x99, 0x91, 0xc4, 0x44, 0x28, 0x85, 0x87, 0x4, 0x44, 0x54, 0xcb, 0x47, 0x28, 0xd5, 0x8f, 0xc4, 0x89, 0x38, 0xfb, 0xce, 0xf6, 0xba, 0x35, 0x74, 0xf1, 0x52, 0xb4, 0x5a, 0x8e, 0x4e, 0x4a, 0xc3, 0x23, 0xe3, 0xfe, 0xac, 0x9, 0xf9, 0x1, 0x37, 0xd4, 0xa, 0x54, 0x81, 0x63, 0x93, 0x56, 0xeb, 0x7d, 0x23, 0x13, 0x20, 0x7f, 0xb7, 0x47, 0xe3, 0x33, 0xb8, 0x2e, 0x5, 0xc3, 0x96, 0xdd, 0x20, 0x56, 0xca, 0x48, 0xd1, 0x6b, 0x48, 0x10, 0x6, 0x26, 0xb3, 0x84, 0x18},
		}

	case 44:
		return flow.Header{
			ChainID:     dps.FlowTestnet,
			ParentID:    flow.HashToID([]byte{0xda, 0xb1, 0x86, 0xb4, 0x51, 0x99, 0xc0, 0xc2, 0x60, 0x60, 0xea, 0x9, 0x28, 0x8b, 0x2f, 0x16, 0x3, 0x2d, 0xa4, 0xf, 0xc5, 0x4c, 0x81, 0xbb, 0x2a, 0x82, 0x67, 0xa5, 0xc1, 0x39, 0x6, 0xe6}),
			Height:      44,
			PayloadHash: flow.HashToID([]byte{0x80, 0xfe, 0xaf, 0x28, 0x4f, 0x8a, 0x51, 0x6c, 0x8c, 0x8, 0x6a, 0x9f, 0xae, 0xc0, 0xbd, 0xbb, 0x6b, 0xcd, 0xf1, 0xc8, 0x2b, 0x4f, 0xc6, 0xdb, 0x35, 0xff, 0x75, 0x42, 0x11, 0x8, 0x1b, 0xd9}),
			Timestamp:   time.Unix(0, 1621341193243086400).UTC(),
			View:        45,
			ParentVoterIDs: []flow.Identifier{
				flow.HashToID([]byte{0x45, 0x51, 0xbe, 0x34, 0xd9, 0xf7, 0xa9, 0x3b, 0x0, 0xd2, 0x87, 0xbd, 0x68, 0x3f, 0x7d, 0xd6, 0x34, 0x5e, 0x65, 0x90, 0x72, 0x40, 0x40, 0x5, 0x54, 0xfb, 0xdf, 0xa1, 0x69, 0x7d, 0x3b, 0xfa}),
				flow.HashToID([]byte{0x5, 0x55, 0x33, 0x7e, 0xf, 0x66, 0x1e, 0xc9, 0xb0, 0x7e, 0xbb, 0x69, 0x46, 0x8, 0x13, 0x16, 0xfa, 0x65, 0xc0, 0xba, 0xca, 0x6b, 0xd4, 0x70, 0x5b, 0xf6, 0x9d, 0x56, 0xa9, 0xf5, 0xb8, 0xa3}),
				flow.HashToID([]byte{0xd3, 0x5f, 0xac, 0xa6, 0x7a, 0xbc, 0x6, 0xc3, 0x34, 0xb1, 0xe5, 0xa7, 0x88, 0x23, 0x98, 0xda, 0xe9, 0xc1, 0xda, 0xd9, 0x13, 0xe5, 0x60, 0x9e, 0xe1, 0xd4, 0x63, 0xd5, 0x5a, 0x22, 0x44, 0xf7}),
			},
			ParentVoterSig: []byte{0x8f, 0x90, 0xd9, 0xf6, 0x9, 0xc9, 0x9, 0xb7, 0x5b, 0x46, 0x7d, 0x4a, 0x17, 0xdb, 0x4e, 0xb7, 0xce, 0xc0, 0x8, 0x7e, 0xcb, 0xf6, 0xde, 0x76, 0xc6, 0xf5, 0x31, 0xbe, 0x13, 0xa3, 0x90, 0xc, 0xc3, 0x8f, 0x33, 0xeb, 0x50, 0xfc, 0x4d, 0x93, 0xb3, 0x64, 0xe8, 0x80, 0x74, 0x51, 0xc4, 0xb3, 0x8c, 0x41, 0xd7, 0xb5, 0xd5, 0x51, 0x72, 0x15, 0x4f, 0x7, 0x95, 0xfb, 0xcf, 0x54, 0xa7, 0x92, 0xa0, 0x90, 0x98, 0x9d, 0x57, 0xc2, 0xb2, 0x7a, 0xe3, 0x1e, 0x5b, 0xbd, 0x2c, 0x5d, 0x71, 0x23, 0x48, 0x87, 0xda, 0xb7, 0x4a, 0x13, 0xf1, 0xea, 0x37, 0x41, 0x53, 0xb7, 0xf4, 0x1f, 0x53, 0x30},
			ProposerID:     flow.HashToID([]byte{0x45, 0x51, 0xbe, 0x34, 0xd9, 0xf7, 0xa9, 0x3b, 0x0, 0xd2, 0x87, 0xbd, 0x68, 0x3f, 0x7d, 0xd6, 0x34, 0x5e, 0x65, 0x90, 0x72, 0x40, 0x40, 0x5, 0x54, 0xfb, 0xdf, 0xa1, 0x69, 0x7d, 0x3b, 0xfa}),
			ProposerSig:    []byte{0x8f, 0x30, 0x2d, 0x1f, 0xb1, 0x6c, 0x30, 0x24, 0xf0, 0x6, 0x76, 0x95, 0x30, 0xeb, 0xda, 0x22, 0xea, 0x7f, 0x4, 0x8a, 0x2e, 0x76, 0x8a, 0x72, 0xcd, 0x91, 0x29, 0x9b, 0xca, 0x3e, 0xf, 0x78, 0x31, 0xf, 0x79, 0x1, 0x68, 0xb4, 0x26, 0xc1, 0x92, 0x48, 0xf8, 0xaa, 0xb6, 0x41, 0x85, 0x70, 0xb3, 0x3, 0x23, 0x4e, 0x22, 0xf0, 0x1a, 0x69, 0x73, 0x55, 0x4c, 0x91, 0xdb, 0xde, 0x8b, 0x7f, 0xf6, 0xa8, 0xe1, 0x6f, 0xf4, 0xf7, 0xd3, 0x51, 0xd7, 0xd2, 0xf5, 0x90, 0x1e, 0x2a, 0x95, 0xa, 0xd5, 0x11, 0xf3, 0xec, 0x53, 0x87, 0x5, 0xf, 0x21, 0xba, 0xfe, 0x98, 0x97, 0x93, 0xb3, 0xc},
		}

	case 425:

		return flow.Header{
			ChainID:     dps.FlowTestnet,
			ParentID:    flow.HashToID([]byte{0x6a, 0xf2, 0x66, 0x21, 0xec, 0xa9, 0x2b, 0xab, 0xda, 0x2d, 0xf3, 0xeb, 0xcd, 0x2f, 0xe2, 0x69, 0x94, 0x6b, 0x3b, 0xf2, 0x8, 0x18, 0x35, 0x69, 0x25, 0x86, 0x30, 0xe6, 0x44, 0x86, 0x83, 0x1d}),
			Height:      425,
			PayloadHash: flow.HashToID([]byte{0xca, 0x42, 0x4b, 0x9c, 0x56, 0xeb, 0xb7, 0x1d, 0xbf, 0xaa, 0x5d, 0x3b, 0xbd, 0xfa, 0x2f, 0xf6, 0x2b, 0x39, 0x7b, 0xb9, 0xcd, 0x4, 0x5, 0xfe, 0x8c, 0xd8, 0x9d, 0x5e, 0xe7, 0x74, 0x25, 0x7a}),
			Timestamp:   time.Unix(0, 1621375483243086400).UTC(),
			View:        427,
			ParentVoterIDs: []flow.Identifier{
				flow.HashToID([]byte{0x45, 0x51, 0xbe, 0x34, 0xd9, 0xf7, 0xa9, 0x3b, 0x0, 0xd2, 0x87, 0xbd, 0x68, 0x3f, 0x7d, 0xd6, 0x34, 0x5e, 0x65, 0x90, 0x72, 0x40, 0x40, 0x5, 0x54, 0xfb, 0xdf, 0xa1, 0x69, 0x7d, 0x3b, 0xfa}),
				flow.HashToID([]byte{0xd3, 0x5f, 0xac, 0xa6, 0x7a, 0xbc, 0x6, 0xc3, 0x34, 0xb1, 0xe5, 0xa7, 0x88, 0x23, 0x98, 0xda, 0xe9, 0xc1, 0xda, 0xd9, 0x13, 0xe5, 0x60, 0x9e, 0xe1, 0xd4, 0x63, 0xd5, 0x5a, 0x22, 0x44, 0xf7}),
				flow.HashToID([]byte{0x5, 0x55, 0x33, 0x7e, 0xf, 0x66, 0x1e, 0xc9, 0xb0, 0x7e, 0xbb, 0x69, 0x46, 0x8, 0x13, 0x16, 0xfa, 0x65, 0xc0, 0xba, 0xca, 0x6b, 0xd4, 0x70, 0x5b, 0xf6, 0x9d, 0x56, 0xa9, 0xf5, 0xb8, 0xa3}),
			},
			ParentVoterSig: []byte{0xa9, 0x69, 0xb8, 0x57, 0xaf, 0xff, 0xd9, 0x4c, 0xd8, 0x94, 0x34, 0xc, 0xd8, 0xad, 0xa4, 0xb2, 0xe6, 0xd2, 0x8f, 0x18, 0x17, 0xa8, 0xa8, 0xc4, 0x80, 0x1e, 0x7a, 0x82, 0x90, 0xed, 0x58, 0x38, 0xf3, 0x2c, 0x4c, 0xa3, 0x31, 0xe3, 0x2b, 0x7e, 0x7c, 0x4b, 0xef, 0x5, 0x22, 0x9, 0xc4, 0xbc, 0xaf, 0x22, 0x1, 0x12, 0x4e, 0x37, 0xbb, 0xb1, 0xeb, 0xbb, 0x26, 0x9, 0x94, 0x6e, 0x7c, 0x49, 0xca, 0xba, 0xdc, 0x4f, 0x68, 0xbf, 0xd9, 0xb9, 0xc, 0x7e, 0x5d, 0xc1, 0x74, 0x1f, 0x4e, 0x5, 0xa2, 0xc5, 0x9f, 0x9b, 0x57, 0xb1, 0xfb, 0x75, 0x20, 0x95, 0xa3, 0x53, 0x7d, 0xa3, 0xa0, 0x3e},
			ProposerID:     flow.HashToID([]byte{0xd3, 0x5f, 0xac, 0xa6, 0x7a, 0xbc, 0x6, 0xc3, 0x34, 0xb1, 0xe5, 0xa7, 0x88, 0x23, 0x98, 0xda, 0xe9, 0xc1, 0xda, 0xd9, 0x13, 0xe5, 0x60, 0x9e, 0xe1, 0xd4, 0x63, 0xd5, 0x5a, 0x22, 0x44, 0xf7}),
			ProposerSig:    []byte{0xa5, 0x58, 0x17, 0xf4, 0x1c, 0x51, 0x43, 0xb7, 0x89, 0xd5, 0x65, 0xb4, 0x68, 0x21, 0xe2, 0x54, 0x78, 0xf4, 0xc2, 0xe7, 0x51, 0xd5, 0xd3, 0xe8, 0xbd, 0xbb, 0x1a, 0xb5, 0x90, 0xf8, 0xb, 0x5a, 0x32, 0xb8, 0x3d, 0xf6, 0xbc, 0xf, 0x10, 0x11, 0x71, 0x24, 0x6f, 0xe4, 0x77, 0x71, 0x8c, 0x32, 0x84, 0xfd, 0x52, 0xf5, 0x31, 0xc7, 0x1f, 0xe7, 0x4d, 0x43, 0xfe, 0xc9, 0xfa, 0x3b, 0x78, 0x67, 0xcc, 0xfe, 0x77, 0xd4, 0xfc, 0x42, 0x74, 0x36, 0x0, 0x9e, 0xf, 0x99, 0xf7, 0xaa, 0xb4, 0xc3, 0xf3, 0xff, 0x3a, 0x17, 0x6e, 0xc3, 0xd7, 0x3d, 0x41, 0xc2, 0x50, 0x7, 0x33, 0xb5, 0x17, 0x83},
		}

	default:
		return flow.Header{}
	}
}
